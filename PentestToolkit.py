import socket
import threading
from concurrent.futures import ThreadPoolExecutor
import requests
import hashlib
import sys
import time
import re
import subprocess
import os



# For colored terminal output
try:
    from colorama import init, Fore, Style
    init(autoreset=True)
except ImportError:
    print("Colorama module not found. Install with: pip install colorama")
    sys.exit(1)

def slow_print(text, delay=0.03):
    for char in text:
        print(char, end='', flush=True)
        time.sleep(delay)
    print()

class PortScanner:
    def _init_(self, target, ports=None, threads=150):
        self.target = target
        self.ports = ports if ports else range(1, 1025)
        self.threads = threads
        self.open_ports = []
        self.lock = threading.Lock()

    def scan_port(self, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(0.8)
                result = s.connect_ex((self.target, port))
                if result == 0:
                    with self.lock:
                        self.open_ports.append(port)
                        print(f"{Fore.CYAN}[+] Port {port} is OPEN{Style.RESET_ALL}")
        except Exception:
            pass

    def run(self):
        slow_print(f"{Fore.YELLOW}Starting port scan on {self.target}...{Style.RESET_ALL}")
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.scan_port, self.ports)
        if self.open_ports:
            slow_print(f"{Fore.GREEN}Scan complete. Open ports: {self.open_ports}{Style.RESET_ALL}")
        else:
            slow_print(f"{Fore.RED}No open ports found.{Style.RESET_ALL}")

class BruteForcer:
    def _init_(self, target, port, username, password_list, threads=20):
        self.target = target
        self.port = port
        self.username = username
        self.password_list = password_list
        self.threads = threads
        self.found = threading.Event()
        self.lock = threading.Lock()

    def try_password(self, password):
        if self.found.is_set():
            return
        # Placeholder for real auth logic
        time.sleep(0.1)
        if password == "password123":
            with self.lock:
                print(f"{Fore.GREEN}[+] Password found: {password}{Style.RESET_ALL}")
            self.found.set()

    def run(self):
        slow_print(f"{Fore.YELLOW}Starting brute force on {self.target}:{self.port} with user '{self.username}'...{Style.RESET_ALL}")
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.try_password, self.password_list)
        if not self.found.is_set():
            slow_print(f"{Fore.RED}[-] Password not found in wordlist.{Style.RESET_ALL}")

class SSHBruteForcer:
    def _init_(self, target, port, username, password_list, threads=10):
        self.target = target
        self.port = port
        self.username = username
        self.password_list = password_list
        self.threads = threads
        self.found = threading.Event()
        self.lock = threading.Lock()

    def try_password(self, password):
        if self.found.is_set():
            return
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(self.target, port=self.port, username=self.username, password=password, timeout=5, banner_timeout=5, auth_timeout=5)
            with self.lock:
                print(f"{Fore.GREEN}[+] SSH Password found: {password}{Style.RESET_ALL}")
            self.found.set()
            ssh.close()
        except paramiko.AuthenticationException:
            pass
        except (paramiko.SSHException, socket.error):
            pass
        except Exception:
            pass

    def run(self):
        slow_print(f"{Fore.YELLOW}Starting SSH brute force on {self.target}:{self.port} with user '{self.username}'...{Style.RESET_ALL}")
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.try_password, self.password_list)
        if not self.found.is_set():
            slow_print(f"{Fore.RED}[-] SSH Password not found in wordlist.{Style.RESET_ALL}")

class BannerGrabber:
    def _init_(self, target, ports=None):
        self.target = target
        self.ports = ports if ports else [21, 22, 25, 80, 110, 143, 443]

    def grab_banner(self, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((self.target, port))
                s.sendall(b'HEAD / HTTP/1.0\r\n\r\n')
                banner = s.recv(1024).decode(errors='ignore').strip()
                if banner:
                    print(f"{Fore.MAGENTA}[+] Port {port} banner:\n{banner}{Style.RESET_ALL}\n")
                else:
                    print(f"{Fore.YELLOW}[-] Port {port} open but no banner received.{Style.RESET_ALL}")
        except Exception:
            print(f"{Fore.RED}[-] Port {port} closed or no response.{Style.RESET_ALL}")

    def run(self):
        slow_print(f"{Fore.YELLOW}Grabbing service banners from {self.target}...{Style.RESET_ALL}")
        for port in self.ports:
            self.grab_banner(port)

class DirEnumerator:
    def _init_(self, target_url, wordlist):
        self.target_url = target_url.rstrip('/')
        self.wordlist = wordlist

    def run(self):
        slow_print(f"{Fore.YELLOW}Starting directory enumeration on {self.target_url}...{Style.RESET_ALL}")
        try:
            with open(self.wordlist, 'r') as f:
                paths = f.read().splitlines()
        except Exception as e:
            print(f"{Fore.RED}Error reading wordlist: {e}{Style.RESET_ALL}")
            return

        for path in paths:
            url = f"{self.target_url}/{path}"
            try:
                r = requests.get(url, timeout=4)
                if r.status_code == 200:
                    print(f"{Fore.GREEN}[+] Found: {url}{Style.RESET_ALL}")
                elif r.status_code == 403:
                    print(f"{Fore.YELLOW}[!] Forbidden (403): {url}{Style.RESET_ALL}")
            except Exception:
                pass

class HashCracker:
    def _init_(self, hash_value, hash_type, wordlist):
        self.hash_value = hash_value.lower()
        self.hash_type = hash_type.lower()
        self.wordlist = wordlist

    def hash_password(self, password):
        if self.hash_type == 'md5':
            return hashlib.md5(password.encode()).hexdigest()
        elif self.hash_type == 'sha1':
            return hashlib.sha1(password.encode()).hexdigest()
        else:
            return None

    def run(self):
        slow_print(f"{Fore.YELLOW}Cracking {self.hash_type} hash: {self.hash_value}{Style.RESET_ALL}")
        try:
            with open(self.wordlist, 'r') as f:
                passwords = f.read().splitlines()
        except Exception as e:
            print(f"{Fore.RED}Error reading wordlist: {e}{Style.RESET_ALL}")
            return

        for pwd in passwords:
            hashed = self.hash_password(pwd)
            if hashed == self.hash_value:
                print(f"{Fore.GREEN}[+] Password found: {pwd}{Style.RESET_ALL}")
                return
        print(f"{Fore.RED}[-] Password not found in wordlist.{Style.RESET_ALL}")

class SQLInjector:
    def _init_(self, target_url, param):
        self.target_url = target_url
        self.param = param

    def test_injection(self):
        payloads = ["' OR '1'='1", "' OR '1'='2", "';--", "\" OR \"1\"=\"1", "' OR 1=1--"]
        vulnerable = False
        for payload in payloads:
            test_url = f"{self.target_url}?{self.param}={payload}"
            try:
                r = requests.get(test_url, timeout=5)
                errors = ["sql syntax", "mysql", "syntax error", "unclosed quotation mark", "odbc", "sqlstate"]
                if any(err in r.text.lower() for err in errors):
                    print(f"{Fore.RED}[!] Possible SQL Injection vulnerability detected with payload: {payload}{Style.RESET_ALL}")
                    vulnerable = True
            except Exception:
                pass
        if not vulnerable:
            print(f"{Fore.GREEN}[-] No SQL Injection vulnerability detected.{Style.RESET_ALL}")

    def run(self):
        slow_print(f"{Fore.YELLOW}Testing SQL Injection on {self.target_url} parameter '{self.param}'...{Style.RESET_ALL}")
        self.test_injection()

class PacketSniffer:
    def _init_(self, interface='eth0', packet_count=10):
        self.interface = interface
        self.packet_count = packet_count

    def run(self):
        slow_print(f"{Fore.YELLOW}Starting packet sniffing on interface {self.interface} for {self.packet_count} packets...{Style.RESET_ALL}")
        try:
            subprocess.run(['tcpdump', '-i', self.interface, '-c', str(self.packet_count), '-nn'], check=True)
        except Exception as e:
            print(f"{Fore.RED}Error running packet sniffer: {e}{Style.RESET_ALL}")

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def main():
    clear_screen()
    slow_print(f"{Fore.CYAN}ðŸ›¡ Developed with ðŸ–¤ by Falah{Style.RESET_ALL}\n")

    while True:
        print(f"{Fore.LIGHTBLUE_EX}Select an option:{Style.RESET_ALL}")
        print(f"{Fore.LIGHTGREEN_EX}1.{Style.RESET_ALL} Port Scanner")
        print(f"{Fore.LIGHTGREEN_EX}2.{Style.RESET_ALL} Brute Forcer (Generic Placeholder)")
        print(f"{Fore.LIGHTGREEN_EX}3.{Style.RESET_ALL} Service Banner Grabber")
        print(f"{Fore.LIGHTGREEN_EX}4.{Style.RESET_ALL} Directory/File Enumerator")
        print(f"{Fore.LIGHTGREEN_EX}5.{Style.RESET_ALL} Password Hash Cracker")
        print(f"{Fore.LIGHTGREEN_EX}6.{Style.RESET_ALL} SQL Injection Tester")
        print(f"{Fore.LIGHTGREEN_EX}7.{Style.RESET_ALL} Packet Sniffer")
        print(f"{Fore.LIGHTGREEN_EX}8.{Style.RESET_ALL} SSH Brute Forcer")
        print(f"{Fore.LIGHTGREEN_EX}0.{Style.RESET_ALL} Exit")

        choice = input(f"{Fore.LIGHTCYAN_EX}>> {Style.RESET_ALL}").strip()

        if choice == '1':
            target = input("Target IP or hostname: ").strip()
            ports = input("Ports (comma-separated, leave blank for 1-1024): ").strip()
            if ports:
                try:
                    ports = [int(p) for p in ports.split(',')]
                except ValueError:
                    print(f"{Fore.RED}Invalid port list.{Style.RESET_ALL}")
                    continue
            else:
                ports = None
            scanner = PortScanner(target, ports)
            scanner.run()

        elif choice == '2':
            target = input("Target IP or hostname: ").strip()
            try:
                port = int(input("Target port: ").strip())
            except ValueError:
                print(f"{Fore.RED}Invalid port.{Style.RESET_ALL}")
                continue
            username = input("Username: ").strip()
            wordlist = input("Password wordlist file path: ").strip()
            try:
                with open(wordlist, 'r') as f:
                    passwords = f.read().splitlines()
            except Exception as e:
                print(f"{Fore.RED}Error reading wordlist: {e}{Style.RESET_ALL}")
                continue
            brute = BruteForcer(target, port, username, passwords)
            brute.run()

        elif choice == '3':
            target = input("Target IP or hostname: ").strip()
            ports = input("Ports (comma-separated, leave blank for common ports): ").strip()
            if ports:
                try:
                    ports = [int(p) for p in ports.split(',')]
                except ValueError:
                    print(f"{Fore.RED}Invalid port list.{Style.RESET_ALL}")
                    continue
            else:
                ports = None
            grabber = BannerGrabber(target, ports)
            grabber.run()

        elif choice == '4':
            url = input("Target URL (e.g., http://example.com): ").strip()
            wordlist = input("Wordlist file path: ").strip()
            enumerator = DirEnumerator(url, wordlist)
            enumerator.run()

        elif choice == '5':
            hash_value = input("Hash to crack: ").strip()
            hash_type = input("Hash type (md5/sha1): ").strip()
            wordlist = input("Wordlist file path: ").strip()
            cracker = HashCracker(hash_value, hash_type, wordlist)
            cracker.run()

        elif choice == '6':
            url = input("Target URL (e.g., http://example.com/page.php): ").strip()
            param = input("Parameter to test (e.g., id): ").strip()
            injector = SQLInjector(url, param)
            injector.run()

        elif choice == '7':
            interface = input("Network interface (default eth0): ").strip() or 'eth0'
            count = input("Number of packets to capture (default 10): ").strip()
            count = int(count) if count.isdigit() else 10
            sniffer = PacketSniffer(interface, count)
            sniffer.run()

        elif choice == '8':
            target = input("Target IP or hostname: ").strip()
            try:
                port = int(input("Target SSH port (default 22): ").strip() or "22")
            except ValueError:
                print(f"{Fore.RED}Invalid port.{Style.RESET_ALL}")
                continue
            username = input("Username: ").strip()
            wordlist = input("Password wordlist file path: ").strip()
            try:
                with open(wordlist, 'r') as f:
                    passwords = f.read().splitlines()
            except Exception as e:
                print(f"{Fore.RED}Error reading wordlist: {e}{Style.RESET_ALL}")
                continue
            ssh_brute = SSHBruteForcer(target, port, username, passwords)
            ssh_brute.run()

        elif choice == '0':
            slow_print(f"{Fore.LIGHTRED_EX}Exiting toolkit. Stay ethical!{Style.RESET_ALL}")
            break

        else:
            print(f"{Fore.RED}Invalid option. Please try again.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
